#![allow(dead_code)]

use std::{
    fmt::Display,
    ops::{Add, Mul, Neg},
};

use super::plonk::{f101, F101};

/// Helper to build a G1 point at $(x,y)$
#[allow(non_snake_case)]
pub fn g1f(x: u64, y: u64) -> G1Point {
    G1Point::new(f101(x), f101(y))
}

/// Helper to build a G2 extension at $a+bu$
#[allow(non_snake_case)]
pub fn g2f(a: u64, b: u64) -> G2Point {
    G2Point::new(f101(a), f101(b))
}

/// A point in the $y^2+x^3+3$ curve, on the $\mathbb{F}_{101}$ field.
/// The generator $g=(1,2)$ generates a subgroup of order 17: $17g=g$
///
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct G1Point {
    /// x coordinate
    pub x: F101,
    /// y coordinate
    pub y: F101,
    /// if point is at infinity
    pub infinite: bool,
}

/// An elliptic curve is an equation of the form $y^2=x^3+ax+b$ where $a$, $b$, $x$, and $y$
/// are elements of some field. (In a cryptographic setting the field will be a finite field.)
/// Any $(x,y)$ pairs satisfying the equation are points on the curve.
///
/// We will use an elliptic curve over the field $\mathbb{F}_{101}$ , which makes hand computation easy.
///
/// The elliptic curve $y^2 = x^3 +3$ is a commonly-used elliptic curve equation, and $(1,2)$ is an easy-to-find
/// point on that curve we can use as a generator. In fact, the alt_bn128 curve that is implemented on Ethereum
/// uses this same curve equation and generator, but over a much larger field.
///
/// Point addition:
/// for $P_r = P_p +  P_q$ , $x_r = \lambda^2 - x_p - x_q$ $y_r = \lambda(x_p - x_r) - y_p$
/// where $\\lambda = \\frac{y_q - y_p}{x_q - x_p}$
///
/// Point doubling (This doubling formula only works for curves with a=0, like ours)
/// for $P=(x,y)$, $2P=(m^2-2x, m(3x-m^2)-y)$ where $m=\\frac{3x^2}{2y}$
///
/// Point inversion:
/// for $P=(x,y)$,  $-P=(x,-y)$
///
/// Elliptic curves also have an abstract "point at infinity" which serves as the group identity. For more on elliptic curve arithmetic, check out [this post from Nick Sullivan](https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/)
///
impl G1Point {
    /// Creates a new point at given $(x,y)$
    pub fn new(x: F101, y: F101) -> Self {
        G1Point {
            x,
            y,
            infinite: false,
        }
    }
    /// Checks if the coordinates are on the curve, so $y^2 = x^3 +3$
    pub fn in_curve(&self) -> bool {
        self.y.pow(2) == self.x.pow(3) + f101(3)
    }
    /// Checks if the point is at infinity
    pub fn is_identity(&self) -> bool {
        self.infinite
    }
    /// Returns the generator $g=(1,2)$
    pub fn generator() -> Self {
        G1Point {
            x: f101(1),
            y: f101(2),
            infinite: false,
        }
    }
    /// Returns the size of the subgroup generated by generator $g=(1,2)$
    pub fn generator_subgroup_size() -> u64 {
        17
    }
    /// Returns the point at infinity
    pub fn identity() -> Self {
        G1Point {
            x: f101(0),
            y: f101(0),
            infinite: true,
        }
    }
}

#[derive(Debug, Copy, Clone, PartialEq)]
pub struct G2Point {
    pub a: F101,
    pub b: F101,
}
impl G2Point {
    // a + b Â· u
    pub fn new(a: F101, b: F101) -> Self {
        G2Point { a, b }
    }
    pub fn generator() -> Self {
        G2Point {
            a: f101(36),
            b: f101(31),
        }
    }
    pub fn embeeding_degree() -> u32 {
        2
    }
    pub fn pow(&self, mut n: u64) -> Self {
        // frobenious map reduction: p^101 = -p
        let (mut p, mut base) = if n >= 101 {
            let base = -self.pow(n / 101);
            n = n % 101;
            (base, *self)
        } else {
            (G2Point::new(f101(1), f101(0)), *self)
        };

        // montgomery reduction
        while n > 0 {
            if n % 2 == 1 {
                p = p * base;
            }
            n = n >> 1;
            base = base * base;
        }

        p
    }
}

impl Display for G1Point {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        if self.infinite {
            write!(f, "infinite")
        } else {
            write!(f, "({},{})", self.x, self.y)
        }
    }
}

impl Display for G2Point {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{}+{}u", self.a, self.b)
    }
}

impl Neg for G1Point {
    type Output = G1Point;
    fn neg(self) -> Self::Output {
        if self.infinite {
            self
        } else {
            G1Point::new(self.x, -self.y)
        }
    }
}

impl Neg for G2Point {
    type Output = G2Point;
    fn neg(self) -> Self::Output {
        G2Point::new(self.a, -self.b)
    }
}

impl Add for G1Point {
    type Output = G1Point;
    fn add(self, rhs: G1Point) -> Self {
        if self.infinite {
            rhs
        } else if rhs.infinite {
            self
        } else if self == -rhs {
            G1Point::identity()
        } else if self == rhs {
            let two = F101::from(2);
            let three = F101::from(3);
            let m = ((three * self.x.pow(2)) / (two * self.y)).unwrap();
            G1Point::new(
                m * m - two * self.x,
                m * (three * self.x - m.pow(2)) - self.y,
            )
        } else {
            // https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication#G1Point_addition
            let lambda = ((rhs.y - self.y) / (rhs.x - self.x))
                .expect(&format!("cannot add {}+{}", self, rhs));
            let x = lambda.pow(2) - self.x - rhs.x;
            G1Point::new(x, lambda * (self.x - x) - self.y)
        }
    }
}

impl Add for G2Point {
    type Output = G2Point;
    fn add(self, rhs: G2Point) -> Self {
        if self == rhs {
            let two = F101::from(2);
            let three = F101::from(3);
            let m_u = ((three * self.a.pow(2)) / (two * self.b)).unwrap(); // in u units
            let u_pow_2_inv = (-F101::from(2)).inv().unwrap(); // 1/(u^2) = -1/2
            let m_pow_2 = m_u.pow(2) * u_pow_2_inv;
            G2Point::new(
                m_pow_2 - two * self.a,
                u_pow_2_inv * m_u * (three * self.a - m_pow_2) - self.b,
            )
        } else {
            let lambda_u = ((rhs.b - self.b) / (rhs.a - self.a)).unwrap();
            let lambda_pow_2 = lambda_u.pow(2) * -f101(2);
            let a = lambda_pow_2 - self.a - rhs.a;
            let b = lambda_u * (self.a - a) - self.b;

            G2Point::new(a, b)
        }
    }
}

impl Mul<F101> for G1Point {
    type Output = G1Point;
    fn mul(self, rhs: F101) -> Self::Output {
        let mut rhs = rhs.as_u64();
        if rhs == 0 || self.is_identity() {
            return G1Point::identity();
        }
        let mut result = None;
        let mut base = self;
        while rhs > 0 {
            if rhs % 2 == 1 {
                result = Some(if let Some(result) = result {
                    result + base
                } else {
                    base
                })
            }
            rhs = rhs >> 1;
            base = base + base;
        }
        result.unwrap()
    }
}

impl Mul<F101> for G2Point {
    type Output = G2Point;
    fn mul(self, rhs: F101) -> Self::Output {
        let mut rhs = rhs.as_u64();
        let mut result = None;
        let mut base = self;
        while rhs > 0 {
            if rhs % 2 == 1 {
                result = Some(if let Some(result) = result {
                    result + base
                } else {
                    base
                })
            }
            rhs = rhs >> 1;
            base = base + base;
        }
        result.unwrap()
    }
}

impl Mul<G2Point> for G2Point {
    type Output = G2Point;
    fn mul(self, rhs: G2Point) -> Self::Output {
        G2Point::new(
            self.a * rhs.a - f101(2) * self.b * rhs.b,
            self.a * rhs.b + self.b * rhs.a,
        )
    }
}

fn pairing_f(r: u64, p: G1Point, q: G2Point) -> G2Point {
    // line equation from a to b point
    let l = |a: G1Point, b: G1Point| {
        let m = b.x - a.x;
        let n = b.y - a.y;

        let x = n;
        let y = -m;
        let c = m * a.y - n * a.x;

        (x, y, c)
    };

    if r == 1 {
        g2f(1, 0)
    } else if r % 2 == 1 {
        let r = r - 1;
        let (x, y, c) = l(p * f101(r), p);
        pairing_f(r, p, q) * G2Point::new(q.a * x + c, q.b * y)
    } else {
        let r = r / 2;
        let (x, y, c) = l(p * f101(r), -p * f101(r) * f101(2));
        pairing_f(r, p, q).pow(2) * G2Point::new(q.a * x + c, q.b * y)
    }
}

pub fn pairing(g1: G1Point, g2: G2Point) -> G2Point {
    let p = g1.x.order();
    let r = G1Point::generator_subgroup_size();
    let k = G2Point::embeeding_degree();

    let exp = (p.pow(k) - 1) / r;

    pairing_f(r, g1, g2).pow(exp)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_find_subgroups() {
        // add all points that are in the curve
        let mut points = Vec::new();
        for x in 0..101 {
            for y in 0..101 {
                let p = G1Point::new(f101(x), f101(y));
                if p.in_curve() {
                    points.push(p);
                }
            }
        }

        // find subgroups
        let mut subgroups = std::collections::HashMap::new();
        while points.len() > 0 {
            let mut in_subgroup = Vec::new();

            // pick one element as a generator
            let g = points.pop().unwrap();
            in_subgroup.push(g);

            // find all m * g != g
            let mut mul = 2;
            let mut gmul = g * f101(mul);
            while g != gmul {
                in_subgroup.push(gmul);
                mul += 1;
                gmul = g * f101(mul);
            }
            in_subgroup.sort();
            subgroups.insert(g, in_subgroup);
        }

        // find unique subgroups
        let mut duplicates = Vec::new();
        for (g, e) in &subgroups {
            if !duplicates.contains(g) {
                subgroups
                    .iter()
                    .filter(|(g1, e1)| g1 != &g && e1 == &e)
                    .for_each(|(g, _)| duplicates.push(*g));
            }
        }

        // remove duplicates
        subgroups.retain(|g, _| !duplicates.contains(g));

        for (g, e) in &subgroups {
            println!("{} {}", g, e.len());
            if e.len() < 20 {
                for n in 0..e.len() {
                    println!("  {}", e[n]);
                }
            }
        }
    }

    #[test]
    fn test_1() {
        use crate::field::Field;
        let a4 = Field::<17>::from(4);
        println!("2,3,4 = {} {} {}", a4.pow(2), a4.pow(3), a4.pow(4));
    }

    #[test]
    fn test_g1_vectors() {
        let g = G1Point::generator();
        let two_g = g + g;
        let four_g = two_g + two_g;
        let eight_g = four_g + four_g;
        let sixteen_g = eight_g + eight_g;

        assert_eq!(g1f(1, 99), -g);
        assert_eq!(g1f(68, 74), two_g);
        assert_eq!(g1f(68, 27), -two_g);
        assert_eq!(g1f(65, 98), four_g);
        assert_eq!(g1f(65, 3), -four_g);
        assert_eq!(g1f(18, 49), eight_g);
        assert_eq!(g1f(18, 52), -eight_g);
        assert_eq!(g1f(1, 99), sixteen_g);
        assert_eq!(g1f(1, 2), -sixteen_g);

        // since g = -16 g, this subgroup has order 17

        assert_eq!(g1f(26, 45), two_g + g);
        assert_eq!(g1f(12, 32), four_g + g);
        assert_eq!(g1f(18, 52), eight_g + g);
        assert_eq!(four_g + two_g, two_g + four_g);

        assert_eq!(g * f101(1), g);
        assert_eq!(g * f101(2), g + g);
        assert_eq!(g * f101(6), g + g + g + g + g + g);
    }

    #[test]
    fn test_g2_vectors() {
        let g = G2Point::generator();

        // check point doubling
        assert_eq!(g2f(90, 82), g + g);

        // check point addition
        assert_eq!((g + g) + (g + g), g + g + g + g);

        // check point multiplication
        assert_eq!(g * f101(6), g + g + g + g + g + g);

        // check G2 multiplication
        assert_eq!(g2f(26, 97) * g2f(93, 76), g2f(97, 89));

        // check G2 exp
        assert_eq!(g2f(42, 49).pow(6), g2f(97, 89));
        assert_eq!(g2f(93, 76).pow(101), -g2f(93, 76));
        assert_eq!(g2f(93, 76).pow(102), (-g2f(93, 76)) * g2f(93, 76));
        assert_eq!(g2f(68, 47).pow(600), g2f(97, 89));
    }
}
